---
title: "R Notebook"
output: html_notebook
---

Introduction of package ClusterR.
Documentation can be found at https://cran.r-project.org/web/packages/ClusterR/vignettes/the_clusterR_package.html.


---> dataset sintetici 2d per visualizzazioni 
  punti generati da gaussiane
  punti generati da PCA di un dataset grande -> proteine? 
  
  
  

-  Introduzione al clustering (cos'Ã¨, immagini d'esempio, esempi di applicazione)
-  Descrizione dei tipi di clustering 
-       Connectivity based
-       Centroid based
-       Distribution based
-       Density based
-  Dataset di esempio della libreria
-  Clustering supportati da ClusterR (centroid based, distribution based)
-  Centroid based clustering (k-means, mini-batch-kmeans, k-medoids)
-       k-means basic usage - KMeans_rcpp
-       variare il numero di k - immagini per diversi k
-       optimal k - Optimal_Clusters_KMeans 
-       visualizzare la bonta del clustering - Silouhette plot
-       misura del tempo di esecuzione - large dataset - KMeans_rcpp vs KMeans_arma vs mini-batck KMeans
-       medoids vs centroids - Cluster_Medoids
-       misura del tempo di esecuzione - Cluster_Medoids vs Clara_Medoids
-  Distribution based clustering
-       Gaussian Mixture Models Optimal_Clusters_GMM 
-       visualizzazione 2d gaussiane
-  Distribution vs Centroid
-       differenze clustering usando i dataset sintetici
-       external_validation per validazione con true label 
-  (optional) paragone ClusteR vs ClusterR




```{r}


# load library MASS
library(MASS)
library(dplyr)

load_factor = 1000

#coeff = log(base=10, load_factor)/2    #choose if augmenting distance when generating more points
coeff = 1
  
# create bivariate normal distribution
df1 = bind_rows(list(
  data.frame(mvrnorm(n = 10 * load_factor, mu = c(5*coeff, 5*coeff), Sigma = matrix(c(1, -.6, 0, 1), ncol = 2)), color="red"),
  data.frame(mvrnorm(n = 10 * load_factor, mu = c(0*coeff, 0*coeff), Sigma = matrix(c(.8, 0, 0, 4), ncol = 2)), color="green"),
  data.frame(mvrnorm(n = 15 * load_factor, mu = c(3*coeff, 1*coeff), Sigma = matrix(c(3, .7, 0, 2), ncol = 2)), color="blue")
))

plot(x=df1$X1, y=df1$X2, col=df1$color)
points(c(5*coeff), c(5*coeff), pch="R", cex=2)
points(c(0*coeff), c(0*coeff), pch="G", cex=2)
points(c(3*coeff), c(1*coeff), pch="B", cex=2)

```







```{r}





```























```{r}
library(ClusterR)
```


```{r}
data(dietary_survey_IBS)
dietary_survey_IBS
```

```{r}
X = dietary_survey_IBS[, -ncol(dietary_survey_IBS)]   # data (excluding the response variable)

y = dietary_survey_IBS[, ncol(dietary_survey_IBS)]    # the response variable

dat = center_scale(X, mean_center = T, sd_scale = T)  # centering and scaling the data

head(dat)
```

```{r}
gmm = GMM(dat, 2, dist_mode = "maha_dist", seed_mode = "random_subset", km_iter = 10,
          em_iter = 10, verbose = F)          

# predict centroids, covariance matrix and weights
pr = predict(gmm, newdata = dat)
```


```{r}
opt_gmm = Optimal_Clusters_GMM(dat, max_clusters = 10, criterion = "BIC",  dist_mode = "maha_dist", seed_mode = "random_subset", km_iter = 10, em_iter = 10, var_floor = 1e-10, plot_data = T)
```


```{r}
res = external_validation(dietary_survey_IBS$class, pr, 
                          method = "adjusted_rand_index", summary_stats = T)

res
```
```{r}
pca_dat = stats::princomp(dat)$scores[, 1:2]

km = KMeans_arma(pca_dat, clusters = 2, n_iter = 10, seed_mode = "random_subset", 
                 
                 verbose = T, CENTROIDS = NULL)

pr = predict_KMeans(pca_dat, km)

table(dietary_survey_IBS$class, pr)

class(km) = 'matrix'

plot_2d(data = pca_dat, clusters = as.vector(pr), centroids_medoids = as.matrix(km))
```
```{r}
library(OpenImageR)

im = readImage('elephant.png')

# first resize the image to reduce the dimensions
im = resizeImage(im, 75, 75, method = 'bilinear')            

imageShow(im) 
```






```{r}
data(mushroom)

X = mushroom[, -1]

y = as.numeric(mushroom[, 1])            # convert the labels to numeric

gwd = FD::gowdis(X)           # calculate the 'gower' distance for the factor variables

gwd_mat = as.matrix(gwd)                 # convert the distances to a matrix

cm = Cluster_Medoids(gwd_mat, clusters = 2, swap_phase = TRUE, verbose = F)
```



















